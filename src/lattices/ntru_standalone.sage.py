#!/usr/bin/env sage
"""
Standalone NTRU Lattice Implementation using SageMath.

This is a self-contained implementation that doesn't require the base lattice class.
"""


# This file was *autogenerated* from the file src/lattices/ntru_standalone.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1p17 = RealNumber('1.17'); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_40 = Integer(40); _sage_const_16 = Integer(16); _sage_const_257 = Integer(257)
from sage.all import *
from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler
import numpy as np
from typing import Optional, Tuple, List, Dict, Union


class NTRULattice:
    """
    NTRU lattice construction for cryptographic applications.
    
    The NTRU lattice basis has the form:
        B = [[g, -f], [G, -F]]^T
    where f, g are secret short polynomials and F, G satisfy fG - gF = q.
    """
    
    def __init__(self, n: int, q: int, sigma: float = None):
        """
        Initialize NTRU lattice parameters.
        
        Args:
            n: Dimension (power of 2 for FFT efficiency)
            q: Modulus (prime)
            sigma: Discrete Gaussian parameter
        """
        self.n = n
        self.q = q
        self.sigma = sigma if sigma is not None else _sage_const_1p17  * sqrt(q)
        
        # Polynomial rings
        self.Zx = PolynomialRing(ZZ, 'x')
        self.x = self.Zx.gen()
        self.R = self.Zx.quotient(self.x**n + _sage_const_1 )
        
        # Ring mod q
        self.Zq = GF(q)
        self.Rq = PolynomialRing(self.Zq, 'x').quotient(self.x**n + _sage_const_1 )
        
        # Discrete Gaussian sampler
        self.dgauss = DiscreteGaussianDistributionIntegerSampler(sigma)
        
        # Keys (to be generated)
        self.f = None
        self.g = None
        self.F = None
        self.G = None
        self.h = None
        self.basis_matrix = None
        
        # FFT setup
        self._init_fft()
    
    def _init_fft(self):
        """Initialize FFT twiddle factors for fast polynomial multiplication."""
        # For cyclotomic polynomial x^n + 1, we need primitive 2n-th root of unity
        self.omega = exp(_sage_const_2 *pi*I/(_sage_const_2 *self.n))
        self.twiddle_factors = [self.omega**i for i in range(self.n)]
        self.inv_twiddle_factors = [self.omega**(-i) for i in range(self.n)]
    
    def _sample_gaussian_poly(self) -> 'R element':
        """Sample polynomial with discrete Gaussian coefficients."""
        coeffs = [self.dgauss() for _ in range(self.n)]
        return self.R(coeffs)
    
    def _add_poly(self, f: 'R element', g: 'R element') -> 'R element':
        """Add two polynomials in R."""
        return f + g
    
    def _multiply_poly(self, f: 'R element', g: 'R element') -> 'R element':
        """Multiply two polynomials in R = Z[x]/(x^n + 1)."""
        # For now, use direct multiplication (FFT can be added later)
        return f * g
    
    def _invert_poly_mod_q(self, f: 'R element') -> Optional['Rq element']:
        """
        Compute f^(-1) mod q in Rq = Z_q[x]/(x^n + 1).
        Returns None if not invertible.
        """
        # Convert to Rq
        f_coeffs = list(f.lift())[:self.n]
        f_mod_q = self.Rq([self.Zq(c) for c in f_coeffs])
        
        try:
            return f_mod_q**(-_sage_const_1 )
        except:
            return None
    
    def _conjugate_poly(self, f: 'R element') -> 'R element':
        """
        Compute conjugate f*(x) = f(x^(-1)) = f(-x) in Z[x]/(x^n + 1).
        
        For f = sum a_i x^i, we have f* = a_0 - sum a_i x^(n-i).
        """
        coeffs = list(f.lift())[:self.n]
        conj_coeffs = [coeffs[_sage_const_0 ]] + [-coeffs[self.n - i] for i in range(_sage_const_1 , self.n)]
        return self.R(conj_coeffs)
    
    def _ntru_solve(self, f: 'R element', g: 'R element') -> Tuple['R element', 'R element']:
        """
        Solve NTRU equation: find F, G such that fG - gF = q.
        
        Uses the field norm approach with K = Q[x]/(x^n + 1).
        """
        # Compute conjugates
        f_conj = self._conjugate_poly(f)
        g_conj = self._conjugate_poly(g)
        
        # Compute norms N(f) = f * f*, N(g) = g * g*
        Nf = self._multiply_poly(f, f_conj)
        Ng = self._multiply_poly(g, g_conj)
        
        # Extract constant terms (field norms are in Z)
        nf = ZZ(Nf.lift()[_sage_const_0 ])
        ng = ZZ(Ng.lift()[_sage_const_0 ])
        
        # Extended GCD: find u, v such that u*N(f) + v*N(g) = gcd(N(f), N(g))
        d, u, v = xgcd(nf, ng)
        
        if d != _sage_const_1 :
            # Scale to make gcd = 1
            u = u * q // d
            v = v * q // d
        else:
            u = u * q
            v = v * q
        
        # Compute F = f* * v, G = g* * u
        F = self._multiply_poly(f_conj, self.R(v))
        G = self._multiply_poly(g_conj, self.R(u))
        
        # Reduce coefficients
        F = self._reduce_poly(F)
        G = self._reduce_poly(G)
        
        return F, G
    
    def _reduce_poly(self, f: 'R element') -> 'R element':
        """Reduce polynomial coefficients to be small."""
        coeffs = list(f.lift())[:self.n]
        # Center reduce modulo q if needed
        reduced_coeffs = []
        for c in coeffs:
            c_mod = c % self.q
            if c_mod > self.q // _sage_const_2 :
                c_mod -= self.q
            reduced_coeffs.append(c_mod)
        return self.R(reduced_coeffs)
    
    def generate_keys(self, max_attempts: int = _sage_const_100 ):
        """
        Generate NTRU key pair (f, g, F, G, h).
        
        Returns:
            Tuple of (f, g, F, G, h) if successful, None otherwise
        """
        for attempt in range(max_attempts):
            # Sample f with extra 1 to ensure invertibility
            f_coeffs = [self.dgauss() for _ in range(self.n)]
            f_coeffs[_sage_const_0 ] += _sage_const_1   # Ensure f(0) != 0 mod q with high probability
            self.f = self.R(f_coeffs)
            
            # Check if f is invertible mod q
            f_inv = self._invert_poly_mod_q(self.f)
            if f_inv is None:
                continue
            
            # Sample g
            self.g = self._sample_gaussian_poly()
            
            # Compute public key h = g/f mod q
            g_mod_q = self.Rq([self.Zq(c) for c in list(self.g.lift())[:self.n]])
            h_mod_q = g_mod_q * f_inv
            self.h = self.R([ZZ(c) for c in list(h_mod_q.lift())])
            
            # Solve NTRU equation
            try:
                self.F, self.G = self._ntru_solve(self.f, self.g)
                
                # Verify solution
                check = self._multiply_poly(self.f, self.G) - self._multiply_poly(self.g, self.F)
                check_coeffs = list(check.lift())
                
                if check_coeffs[_sage_const_0 ] % self.q == _sage_const_0  and all(c == _sage_const_0  for c in check_coeffs[_sage_const_1 :self.n]):
                    # Success! Generate basis matrix
                    self._generate_basis()
                    return (self.f, self.g, self.F, self.G, self.h)
            except Exception as e:
                continue
        
        return None
    
    def _poly_to_matrix(self, f: 'R element') -> Matrix:
        """Convert polynomial to negacyclic circulant matrix."""
        coeffs = list(f.lift())[:self.n]
        M = matrix(ZZ, self.n, self.n)
        
        for i in range(self.n):
            for j in range(self.n):
                if i <= j:
                    M[i, j] = coeffs[j - i]
                else:
                    M[i, j] = -coeffs[self.n + j - i]
        
        return M
    
    def _generate_basis(self):
        """Generate the NTRU lattice basis matrix."""
        # Convert polynomials to matrices
        g_mat = self._poly_to_matrix(self.g)
        f_mat = self._poly_to_matrix(self.f)
        G_mat = self._poly_to_matrix(self.G)
        F_mat = self._poly_to_matrix(self.F)
        
        # Construct basis: B = [[g, -f], [G, -F]]^T
        top_block = block_matrix([[g_mat, -f_mat]])
        bottom_block = block_matrix([[G_mat, -F_mat]])
        self.basis_matrix = block_matrix([[top_block], [bottom_block]])
    
    def get_basis(self) -> Matrix:
        """Get the lattice basis matrix."""
        if self.basis_matrix is None:
            raise ValueError("Keys not generated yet")
        return self.basis_matrix
    
    def gram_schmidt_norms(self) -> List[float]:
        """
        Compute Gram-Schmidt norms of basis vectors.
        
        Uses standard Gram-Schmidt (FFT version can be added later).
        """
        if self.basis_matrix is None:
            raise ValueError("Keys not generated yet")
        
        B = self.basis_matrix.change_ring(RDF)
        n_vecs = B.nrows()
        
        # Gram-Schmidt orthogonalization
        gs_vecs = []
        gs_norms = []
        
        for i in range(n_vecs):
            v = B[i]
            # Subtract projections onto previous vectors
            for j in range(i):
                proj = (v.dot_product(gs_vecs[j]) / gs_norms[j]**_sage_const_2 ) * gs_vecs[j]
                v = v - proj
            
            gs_vecs.append(v)
            gs_norms.append(float(v.norm()))
        
        return gs_norms
    
    def shortest_vector(self) -> vector:
        """Find a short vector in the lattice (approximation)."""
        if self.basis_matrix is None:
            raise ValueError("Keys not generated yet")
        
        # The secret key (f, g) is typically a short vector
        f_vec = vector(ZZ, [])
        g_vec = vector(ZZ, [])
        
        for i in range(self.n):
            f_vec = f_vec.list() + [self.f.lift()[i] if i < len(self.f.lift()) else _sage_const_0 ]
            g_vec = g_vec.list() + [self.g.lift()[i] if i < len(self.g.lift()) else _sage_const_0 ]
        
        # Concatenate to form the short vector [g, -f]
        short = vector(ZZ, list(g_vec) + list(-vector(f_vec)))
        return short
    
    def is_in_lattice(self, v: vector) -> bool:
        """Check if vector v is in the lattice."""
        if self.basis_matrix is None:
            raise ValueError("Keys not generated yet")
        
        # Try to solve Bx = v
        try:
            x = self.basis_matrix.solve_left(v)
            # Check if coefficients are integers
            return all(c in ZZ for c in x)
        except:
            return False
    
    def closest_vector(self, target: vector) -> vector:
        """
        Find closest lattice vector to target using Babai's nearest plane algorithm.
        """
        if self.basis_matrix is None:
            raise ValueError("Keys not generated yet")
        
        # Simple Babai rounding
        coeffs = self.basis_matrix.solve_left(target)
        rounded_coeffs = vector([round(c) for c in coeffs])
        return self.basis_matrix.transpose() * rounded_coeffs


# Example usage
if __name__ == "__main__":
    print("NTRU Lattice Example")
    print("=" * _sage_const_40 )
    
    # Create small NTRU lattice
    ntru = NTRULattice(n=_sage_const_16 , q=_sage_const_257 )
    print(f"Created NTRU lattice: n={ntru.n}, q={ntru.q}")
    
    # Generate keys
    print("\nGenerating keys...")
    keys = ntru.generate_keys()
    if keys:
        f, g, F, G, h = keys
        print("✓ Keys generated successfully")
        
        # Get basis
        B = ntru.get_basis()
        print(f"\nBasis dimensions: {B.nrows()} × {B.ncols()}")
        print(f"Determinant: {abs(B.det())} (expected: {ntru.q**ntru.n})")
        
        # Compute GS norms
        gs_norms = ntru.gram_schmidt_norms()
        print(f"\nGram-Schmidt norms:")
        print(f"  Min: {min(gs_norms):.4f}")
        print(f"  Max: {max(gs_norms):.4f}")
        print(f"  Ratio: {max(gs_norms)/min(gs_norms):.4f}")
    else:
        print("✗ Key generation failed")

