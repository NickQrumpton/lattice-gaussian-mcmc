#!/usr/bin/env sage
"""Debug NTRU key generation."""


# This file was *autogenerated* from the file src/lattices/test_ntru_debug.sage
from sage.all_cmdline import *   # import sage library

_sage_const_8 = Integer(8); _sage_const_257 = Integer(257); _sage_const_1p17 = RealNumber('1.17'); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5)
from sage.all import *

# Setup
n, q = _sage_const_8 , _sage_const_257 
sigma = _sage_const_1p17  * sqrt(q).n()

print(f"Testing NTRU with n={n}, q={q}, sigma={sigma:.2f}")

# Polynomial rings
R = PolynomialRing(ZZ, names=('x',)); (x,) = R._first_ngens(1)
Rmod = R.quotient(x**n + _sage_const_1 )

Rq = PolynomialRing(GF(q), names=('y',)); (y,) = Rq._first_ngens(1)
Rqmod = Rq.quotient(y**n + _sage_const_1 )

# Test 1: Basic polynomial operations
print("\n1. Testing polynomial operations")
f = Rmod([_sage_const_1 , _sage_const_2 , _sage_const_3 , _sage_const_4 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ])
g = Rmod([_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ])
h = f + g
print(f"f = {f}")
print(f"g = {g}")
print(f"f + g = {h}")

# Test 2: Modular inversion
print("\n2. Testing modular inversion")
f_coeffs = [_sage_const_2 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
f = Rmod(f_coeffs)
f_mod_q = Rqmod([GF(q)(c) for c in f_coeffs])

try:
    f_inv = f_mod_q**(-_sage_const_1 )
    print(f"f = {f}")
    print(f"f^(-1) mod q exists")
    
    # Verify
    check = f_mod_q * f_inv
    print(f"f * f^(-1) = {check}")
except:
    print(f"f = {f} is not invertible mod q")

# Test 3: Conjugate
print("\n3. Testing conjugate")
f = Rmod([_sage_const_1 , _sage_const_2 , _sage_const_3 , _sage_const_4 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ])
coeffs = list(f.lift())[:n]
conj_coeffs = [coeffs[_sage_const_0 ]] + [-coeffs[n - i] for i in range(_sage_const_1 , n)]
f_conj = Rmod(conj_coeffs)
print(f"f = {f}")
print(f"f* = {f_conj}")

# Test 4: NTRU solve
print("\n4. Testing NTRU solve")

# Simple f, g
f = Rmod([_sage_const_3 , _sage_const_1 , -_sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , -_sage_const_1 ])
g = Rmod([_sage_const_1 , _sage_const_2 , _sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_1 , -_sage_const_1 , _sage_const_0 ])

# Conjugates
f_coeffs = list(f.lift())[:n]
g_coeffs = list(g.lift())[:n]
f_conj = Rmod([f_coeffs[_sage_const_0 ]] + [-f_coeffs[n-i] for i in range(_sage_const_1 , n)])
g_conj = Rmod([g_coeffs[_sage_const_0 ]] + [-g_coeffs[n-i] for i in range(_sage_const_1 , n)])

# Norms
Nf = f * f_conj
Ng = g * g_conj
nf = ZZ(Nf.lift()[_sage_const_0 ])
ng = ZZ(Ng.lift()[_sage_const_0 ])

print(f"N(f) = {nf}")
print(f"N(g) = {ng}")

# Extended GCD
d, u, v = xgcd(nf, ng)
print(f"gcd(N(f), N(g)) = {d}")

# Scale by q
u_scaled = u * q
v_scaled = v * q

# Compute F, G
F = f_conj * Rmod(v_scaled)
G = g_conj * Rmod(u_scaled)

print(f"\nF has degree {F.lift().degree()}")
print(f"G has degree {G.lift().degree()}")

# Verify
check = f * G - g * F
check_coeffs = list(check.lift())
print(f"\nfG - gF = {check_coeffs[_sage_const_0 ]} + ...")
print(f"Equals q? {check_coeffs[_sage_const_0 ] == q}")

# Test 5: Random key generation
print("\n5. Testing random key generation")
from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler

dgauss = DiscreteGaussianDistributionIntegerSampler(sigma)

success = False
for attempt in range(_sage_const_5 ):
    print(f"\nAttempt {attempt + _sage_const_1 }:")
    
    # Sample f
    f_coeffs = [dgauss() for _ in range(n)]
    f_coeffs[_sage_const_0 ] += _sage_const_1 
    f = Rmod(f_coeffs)
    print(f"  f coeffs: {f_coeffs}")
    
    # Check invertibility
    f_mod_q = Rqmod([GF(q)(c) for c in f_coeffs])
    try:
        f_inv = f_mod_q**(-_sage_const_1 )
        print("  f is invertible mod q ✓")
        
        # Sample g
        g_coeffs = [dgauss() for _ in range(n)]
        g = Rmod(g_coeffs)
        print(f"  g coeffs: {g_coeffs}")
        
        # Try NTRU solve
        try:
            # Conjugates
            f_conj = Rmod([f_coeffs[_sage_const_0 ]] + [-f_coeffs[n-i] for i in range(_sage_const_1 , n)])
            g_conj = Rmod([g_coeffs[_sage_const_0 ]] + [-g_coeffs[n-i] for i in range(_sage_const_1 , n)])
            
            # Norms
            Nf = f * f_conj
            Ng = g * g_conj
            nf = ZZ(Nf.lift()[_sage_const_0 ])
            ng = ZZ(Ng.lift()[_sage_const_0 ])
            
            # GCD
            d, u, v = xgcd(nf, ng)
            
            # Scale
            F = f_conj * Rmod(v * q // d if d != _sage_const_1  else v * q)
            G = g_conj * Rmod(u * q // d if d != _sage_const_1  else u * q)
            
            # Check
            check = f * G - g * F
            check_coeffs = list(check.lift())
            
            if check_coeffs[_sage_const_0 ] % q == _sage_const_0 :
                print("  NTRU equation solved ✓")
                success = True
                break
            else:
                print(f"  NTRU check failed: {check_coeffs[_sage_const_0 ]} mod {q} = {check_coeffs[_sage_const_0 ] % q}")
        except Exception as e:
            print(f"  NTRU solve error: {e}")
    except:
        print("  f not invertible mod q ✗")

if success:
    print("\n✓ Successfully generated NTRU keys!")
else:
    print("\n✗ Failed to generate keys in 5 attempts")

