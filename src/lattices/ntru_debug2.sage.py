#!/usr/bin/env sage
"""Debug NTRU implementation step by step."""


# This file was *autogenerated* from the file src/lattices/ntru_debug2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_8 = Integer(8); _sage_const_257 = Integer(257); _sage_const_1p17 = RealNumber('1.17'); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4)
from sage.all import *
from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler

# Parameters
n = _sage_const_8   # Small for debugging
q = _sage_const_257 
sigma = _sage_const_1p17  * sqrt(q).n()

print(f"NTRU Debug: n={n}, q={q}, sigma={sigma:.2f}")

# Setup rings
R = PolynomialRing(ZZ, names=('x',)); (x,) = R._first_ngens(1)
Rmod = R.quotient(x**n + _sage_const_1 , 'xbar')

Rq = PolynomialRing(GF(q), names=('y',)); (y,) = Rq._first_ngens(1)
Rqmod = Rq.quotient(y**n + _sage_const_1 , 'ybar')

print(f"\nRings created:")
print(f"R = {Rmod}")
print(f"Rq = {Rqmod}")

# Test invertibility of some polynomials
print("\n--- Testing Invertibility ---")

test_polys = [
    [_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ],  # 1
    [_sage_const_2 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ],  # 2 + x
    [_sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ],  # 1 + x
    [_sage_const_3 , _sage_const_1 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ], # 3 + x - x^2
]

for i, coeffs in enumerate(test_polys):
    f_mod = Rmod(coeffs)
    f_q = Rqmod(coeffs)
    
    try:
        f_inv = f_q**(-_sage_const_1 )
        check = f_q * f_inv
        print(f"Poly {i+_sage_const_1 }: {coeffs[:_sage_const_4 ]}... is invertible. Check: {check}")
    except:
        print(f"Poly {i+_sage_const_1 }: {coeffs[:_sage_const_4 ]}... is NOT invertible")

# Test NTRU equation solving
print("\n--- Testing NTRU Equation ---")

# Use small integer polynomials
f_coeffs = [_sage_const_3 , _sage_const_1 , -_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]
g_coeffs = [_sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]

f = Rmod(f_coeffs)
g = Rmod(g_coeffs)

print(f"\nf = {f}")
print(f"g = {g}")

# Helper to get padded coefficients
def get_coeffs(poly, length):
    c = list(poly.lift())
    while len(c) < length:
        c.append(_sage_const_0 )
    return c[:length]

# Compute conjugates
def conjugate(poly_coeffs):
    conj = [poly_coeffs[_sage_const_0 ]]
    for i in range(_sage_const_1 , n):
        conj.append(-poly_coeffs[(n - i) % n])
    return conj

f_star_coeffs = conjugate(f_coeffs)
g_star_coeffs = conjugate(g_coeffs)

f_star = Rmod(f_star_coeffs)
g_star = Rmod(g_star_coeffs)

print(f"\nf* = {f_star}")
print(f"g* = {g_star}")

# Compute norms
Nf = f * f_star
Ng = g * g_star

nf_coeffs = get_coeffs(Nf, n)
ng_coeffs = get_coeffs(Ng, n)

print(f"\nN(f) = {Nf}")
print(f"N(g) = {Ng}")

nf = ZZ(nf_coeffs[_sage_const_0 ])
ng = ZZ(ng_coeffs[_sage_const_0 ])

print(f"\nnf = {nf}, ng = {ng}")

# Extended GCD
d, u, v = xgcd(nf, ng)
print(f"gcd({nf}, {ng}) = {d}")
print(f"u = {u}, v = {v}")
print(f"Check: {u}*{nf} + {v}*{ng} = {u*nf + v*ng}")

# Scale by q
u_scaled = u * q
v_scaled = v * q

print(f"\nScaled: u*q = {u_scaled}, v*q = {v_scaled}")

# Compute F, G
F = f_star * Rmod(v_scaled)
G = g_star * Rmod(u_scaled)

print(f"\nF = {F}")
print(f"G = {G}")

# Verify NTRU equation
check = f * G - g * F
check_coeffs = get_coeffs(check, n)

print(f"\nfG - gF = {check}")
print(f"Constant term: {check_coeffs[_sage_const_0 ]}")
print(f"Equals q? {check_coeffs[_sage_const_0 ] == q}")
print(f"Other coeffs zero? {all(c == _sage_const_0  for c in check_coeffs[_sage_const_1 :])}")

# Try with Gaussian sampling
print("\n--- Testing with Gaussian Sampling ---")

dgauss = DiscreteGaussianDistributionIntegerSampler(sigma)

for attempt in range(_sage_const_3 ):
    print(f"\nAttempt {attempt + _sage_const_1 }:")
    
    # Sample f
    f_coeffs = [dgauss() for _ in range(n)]
    f_coeffs[_sage_const_0 ] += _sage_const_1   # Make more likely to be invertible
    
    print(f"  f coeffs: {f_coeffs}")
    
    # Check if invertible
    f_q = Rqmod(f_coeffs)
    try:
        f_inv = f_q**(-_sage_const_1 )
        print("  ✓ f is invertible mod q")
        
        # Sample g
        g_coeffs = [dgauss() for _ in range(n)]
        print(f"  g coeffs: {g_coeffs}")
        
        # Do NTRU solve
        f = Rmod(f_coeffs)
        g = Rmod(g_coeffs)
        
        f_star = Rmod(conjugate(f_coeffs))
        g_star = Rmod(conjugate(g_coeffs))
        
        Nf = f * f_star
        Ng = g * g_star
        
        nf = ZZ(get_coeffs(Nf, n)[_sage_const_0 ])
        ng = ZZ(get_coeffs(Ng, n)[_sage_const_0 ])
        
        if nf == _sage_const_0  or ng == _sage_const_0 :
            print("  ✗ Norm is zero!")
            continue
            
        d, u, v = xgcd(nf, ng)
        
        F = f_star * Rmod(v * q // d if d > _sage_const_1  else v * q)
        G = g_star * Rmod(u * q // d if d > _sage_const_1  else u * q)
        
        check = f * G - g * F
        check_coeffs = get_coeffs(check, n)
        
        const = check_coeffs[_sage_const_0 ]
        print(f"  fG - gF constant: {const}")
        print(f"  Divisible by q? {const % q == _sage_const_0 }")
        
        if abs(const) == q and all(c == _sage_const_0  for c in check_coeffs[_sage_const_1 :]):
            print("  ✓ NTRU equation solved!")
        else:
            print("  ✗ NTRU equation failed")
            
    except:
        print("  ✗ f not invertible mod q")

