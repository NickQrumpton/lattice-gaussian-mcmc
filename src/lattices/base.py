"""
Abstract base class for lattices in SageMath.

Implements fundamental operations for lattice Gaussian sampling
as described in Wang & Ling (2018).
"""

from abc import ABC, abstractmethod
import numpy as np
from sage.all import (
    Matrix, vector, RR, RDF, ZZ, pi, e, sqrt, log, exp,
    identity_matrix, matrix
)


class Lattice(ABC):
    """
    Abstract base class for lattice implementations.
    
    A lattice Λ ⊂ R^n is a discrete additive subgroup generated by
    linearly independent vectors b_1, ..., b_n ∈ R^n.
    
    Attributes:
        dimension (int): The dimension n of the lattice
        _basis (Matrix): The basis matrix B ∈ R^(n×n)
        _gram_schmidt_basis (Matrix): Gram-Schmidt orthogonalization B*
        _gram_schmidt_coeffs (Matrix): GS coefficients μ_{i,j}
        _gram_schmidt_norms (list): Norms ||b*_i||
        _dual_basis (Matrix): Basis of the dual lattice
        _determinant (RealNumber): det(Λ)
        _volume (RealNumber): Vol(Λ)
    """
    
    def __init__(self, dimension):
        """
        Initialize lattice with given dimension.
        
        Args:
            dimension (int): Lattice dimension n
        """
        self.dimension = dimension
        self._basis = None
        self._gram_schmidt_basis = None
        self._gram_schmidt_coeffs = None
        self._gram_schmidt_norms = None
        self._dual_basis = None
        self._determinant = None
        self._volume = None
        
    @abstractmethod
    def get_basis(self):
        """
        Return the lattice basis matrix B ∈ R^(n×n).
        
        Returns:
            Matrix: Basis matrix where rows are basis vectors
        """
        pass
    
    @abstractmethod
    def get_dimension(self):
        """
        Return lattice dimension n.
        
        Returns:
            int: Dimension of the lattice
        """
        pass
    
    def get_gram_schmidt(self):
        """
        Compute and cache the Gram-Schmidt orthogonalization.
        
        For basis B = [b_1, ..., b_n], computes orthogonal basis
        B* = [b*_1, ..., b*_n] where:
            b*_i = b_i - Σ_{j<i} μ_{i,j} b*_j
            μ_{i,j} = ⟨b_i, b*_j⟩ / ||b*_j||²
        
        Returns:
            tuple: (gram_schmidt_basis, coefficients, norms)
        """
        if self._gram_schmidt_basis is None:
            self._compute_gram_schmidt()
        return (self._gram_schmidt_basis, 
                self._gram_schmidt_coeffs,
                self._gram_schmidt_norms)
    
    def get_dual_basis(self):
        """
        Compute the dual lattice basis.
        
        The dual lattice Λ* = {y ∈ span(Λ) : ⟨y, Λ⟩ ⊆ Z}
        has basis D = B^{-T}.
        
        Returns:
            Matrix: Dual lattice basis
        """
        if self._dual_basis is None:
            basis = self.get_basis()
            if basis.det() == 0:
                raise ValueError("Lattice basis is singular")
            self._dual_basis = basis.inverse().transpose()
        return self._dual_basis
    
    def nearest_plane(self, target):
        """
        Implement Babai's nearest plane algorithm.
        
        Finds lattice vector close to target using successive
        projections onto hyperplanes.
        
        Args:
            target (vector): Target vector t ∈ R^n
            
        Returns:
            vector: Lattice vector v ∈ Λ close to target
        """
        basis = self.get_basis()
        gs_basis, mu, _ = self.get_gram_schmidt()
        
        # Convert target to coefficient vector
        c = vector(RDF, [0] * self.dimension)
        t = vector(RDF, target)
        
        # Project onto successive hyperplanes
        for i in range(self.dimension - 1, -1, -1):
            # Compute coefficient for b*_i
            proj = t.dot_product(gs_basis[i]) / gs_basis[i].dot_product(gs_basis[i])
            c[i] = round(proj)
            
            # Update target by subtracting projection
            t = t - c[i] * basis[i]
            
        # Reconstruct lattice vector
        return sum(c[i] * basis[i] for i in range(self.dimension))
    
    def decode_cvp(self, target, method='babai'):
        """
        Solve the Closest Vector Problem.
        
        Find v ∈ Λ minimizing ||v - t||.
        
        Args:
            target (vector): Target vector t ∈ R^n
            method (str): Algorithm to use ('babai' or 'exact')
            
        Returns:
            vector: Closest lattice vector
        """
        if method == 'babai':
            return self.nearest_plane(target)
        elif method == 'exact':
            # Exact CVP is NP-hard; could implement enumeration
            raise NotImplementedError("Exact CVP not yet implemented")
        else:
            raise ValueError(f"Unknown CVP method: {method}")
    
    def gaussian_heuristic(self):
        """
        Calculate the Gaussian heuristic σ_GH.
        
        σ_GH = √(n/(2πe)) * det(Λ)^(1/n)
        
        Returns:
            RealNumber: Gaussian heuristic value
        """
        n = self.dimension
        det_lattice = self.get_determinant()
        return sqrt(n / (2 * pi * e)) * det_lattice^(1/n)
    
    def smoothing_parameter(self, epsilon=2^(-53)):
        """
        Compute smoothing parameter η_ε(Λ).
        
        For ε > 0, η_ε(Λ) is the smallest s > 0 such that
        ρ_{1/s}(Λ* \ {0}) ≤ ε.
        
        From Lemma 5.1: η_ε(Λ) ≤ √(ln(2n(1+1/ε))/π) / λ_1(Λ*)
        
        Args:
            epsilon (float): Smoothing parameter bound
            
        Returns:
            RealNumber: Smoothing parameter η_ε(Λ)
        """
        n = self.dimension
        # Get first minimum of dual lattice
        dual_basis = self.get_dual_basis()
        lambda1_dual = self._estimate_first_minimum(dual_basis)
        
        # Apply bound from Lemma 5.1
        return sqrt(log(2 * n * (1 + 1/epsilon)) / pi) / lambda1_dual
    
    def first_minimum(self):
        """
        Estimate or compute λ_1(Λ).
        
        The first minimum is the length of shortest nonzero vector.
        
        Returns:
            RealNumber: First minimum λ_1(Λ)
        """
        return self._estimate_first_minimum(self.get_basis())
    
    def covering_radius(self):
        """
        Compute the covering radius.
        
        The covering radius is max_{t ∈ span(Λ)} dist(t, Λ).
        
        Returns:
            RealNumber: Covering radius
        """
        # Upper bound: ρ ≤ (1/2) * Σ ||b*_i||
        _, _, norms = self.get_gram_schmidt()
        return sum(norms) / 2
    
    def fundamental_parallelepiped(self):
        """
        Return the fundamental domain.
        
        P(B) = {Σ x_i b_i : 0 ≤ x_i < 1}
        
        Returns:
            dict: Description of fundamental parallelepiped
        """
        basis = self.get_basis()
        return {
            'basis': basis,
            'description': 'P(B) = {Σ x_i b_i : 0 ≤ x_i < 1}',
            'volume': self.get_volume()
        }
    
    def get_determinant(self):
        """
        Get cached determinant det(Λ).
        
        Returns:
            RealNumber: Determinant of lattice
        """
        if self._determinant is None:
            self._determinant = abs(self.get_basis().det())
        return self._determinant
    
    def get_volume(self):
        """
        Get cached volume Vol(Λ).
        
        Note: Vol(Λ) = det(Λ) for full-rank lattices.
        
        Returns:
            RealNumber: Volume of fundamental parallelepiped
        """
        if self._volume is None:
            self._volume = self.get_determinant()
        return self._volume
    
    def get_gram_schmidt_coefficients(self):
        """
        Get Gram-Schmidt coefficients μ_{i,j}.
        
        Returns:
            Matrix: Upper triangular matrix of coefficients
        """
        if self._gram_schmidt_coeffs is None:
            self.get_gram_schmidt()
        return self._gram_schmidt_coeffs
    
    def get_gram_schmidt_norms(self):
        """
        Get Gram-Schmidt norms ||b*_i||.
        
        Returns:
            list: List of norms
        """
        if self._gram_schmidt_norms is None:
            self.get_gram_schmidt()
        return self._gram_schmidt_norms
    
    def _compute_gram_schmidt(self):
        """
        Internal method to compute Gram-Schmidt orthogonalization.
        
        Uses SageMath's built-in methods for numerical stability.
        """
        basis = self.get_basis()
        n = self.dimension
        
        # Use RDF for numerical stability
        basis_rdf = matrix(RDF, basis)
        
        # Initialize
        gs_basis = matrix(RDF, n, n)
        mu = matrix(RDF, n, n)
        norms = []
        
        # Gram-Schmidt process
        for i in range(n):
            # Start with original vector
            gs_basis[i] = basis_rdf[i]
            
            # Subtract projections
            for j in range(i):
                if norms[j] > 0:
                    mu[i, j] = basis_rdf[i].dot_product(gs_basis[j]) / (norms[j]^2)
                    gs_basis[i] = gs_basis[i] - mu[i, j] * gs_basis[j]
            
            # Compute norm
            norm = sqrt(gs_basis[i].dot_product(gs_basis[i]))
            norms.append(norm)
            
        self._gram_schmidt_basis = gs_basis
        self._gram_schmidt_coeffs = mu
        self._gram_schmidt_norms = norms
    
    def _estimate_first_minimum(self, basis):
        """
        Estimate the first minimum using Gaussian heuristic.
        
        Args:
            basis (Matrix): Lattice basis
            
        Returns:
            RealNumber: Estimate of λ_1
        """
        # Use Minkowski bound as estimate
        n = basis.nrows()
        det = abs(basis.det())
        
        # Hermite's constant γ_n ≈ n/(2πe) for large n
        gamma_n = n / (2 * pi * e)
        
        return sqrt(gamma_n) * det**(1/n)
    
    def __str__(self):
        """String representation of lattice."""
        return f"Lattice(dimension={self.dimension}, det={self.get_determinant():.6f})"
    
    def __repr__(self):
        """Detailed representation of lattice."""
        return self.__str__()